// 디자인 패턴의 핵심 #1. 공통성과 가변성의 분리
// => 변하지 않은 코드 내부의 변하는 것을 찾아서 분리하는 것



// 변하는 것을 어떻게 분리할것인가 ?

// 1. 가상함수로 분리
// => 파생 클래스를 만들어서 가상함수 override 하라는 것
// => 도형편집기의 draw/draw_imp() 모양
// => template method, factory method


// 2. 다른 클래스로 분리
// => 클래스가 사용하는 어떤 정책을 다른 클래스로 분리하는 방법
// => strategy, policy base design


// => 정책을 담을 클래스를 어떻게 교체할것인가 ?
// strategy           : 인터페이스를 사용해서 정책 클래스 교체
//						Edit/IValidator 예제
// 
// policy base design : template 인자를 사용해서 정책 클래스 교체
//						(C++ Idioms)
//						vector/allocator 예제
//						string 의 비교 정책 교체


//							성능						유연성
// strategy					가상함수, 느리다			e.set_validator(&v1)
//													e.set_validator(&v2)
//													실행시간 정책(알고리즘) 교체 가능. 
// 
// policy base design		가상함수아님.				std::vector<int, debug_alloc<int>> v;
//							인라인도가능. 빠르다		v는 실행시간에 메모리 할당 방식교체안됨
//													즉, v를 생성시에 정책전달하고
//													교체는 안됨.



// 참고 : 가상함수!!
// => 프로그램에서 가끔 호출된다면 사용해도 문제 되지 않습니다.
// => 루프안에서 수천~수만번 호출되는 경우는 가상함수는 오버헤드가 큽니다.
// => 또는 STL 설계자들처럼, 모든 개발자가사용하는 라이브러리를 설계 할때 주의..


// 디자인 패턴의 핵심 #2. 재귀적 포함을 사용하는 경우가 많습니다.
// 
// => A는 B를 포함하지만 A 자신도 포함할수 있다.
// => A와 B는 공통의 기반 클래스가 있어야 합니다.

// 왜 ?? 어떤 의도로 재귀적 포함을 사용하는가 ?
// 에 따라서 패턴의 이름을 다릅니다.

// Composite : 재귀적 포함을 사용한 복합객체(여러개 객체를 보관) 만들기
// Decorator : 재귀적 포함을 사용해서 기능을 동적으로 추가


// 디자인 패턴의 핵심 #3. 간접층의 원리로 문제 해결